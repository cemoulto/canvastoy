<!doctype html>
<html>
<head>
<meta charset=utf-8>
<style>
canvas {
  z-index: 1;
  position: absolute;
  right: 0;
  top: 0;
}
#editor {
  position: absolute;
  top: 0;
  left: 0;
  padding: 0.5em;
  margin: 0;
  width: calc(50% - 1.5em);
  height: 100%;
  z-index: 2;
  transition: box-shadow 0.7s;
}
.error {
  box-shadow: 0px 0px 100px red inset;
}

.ok {
  box-shadow: 0px 0px 100px green inset;
}

#versions {
  position: absolute;
  bottom:0;
  right:0;
  z-index: 4;
}
</style>
</head>
<body>
<pre contenteditable id=editor placeholder=>
/* ctrl + enter to render */
/* cv = document.getElementByTagName("canvas")[0] */
/* (w, h) = (cv.width, cv.height) */
/* c = cv.getContext('2d') */
/* b = c.createImageData(w, h) */

noise(b);
</pre>
<canvas>
</canvas>
<select id=versions>
</select>
<script>
/* gaia: shared/js/async_storage.js */
this.asyncStorage = (function() {
  var DBNAME = 'asyncStorage';
  var DBVERSION = 1;
  var STORENAME = 'keyvaluepairs';
  var db = null;

  function withStore(type, f) {
    if (db) {
      f(db.transaction(STORENAME, type).objectStore(STORENAME));
    } else {
      var openreq = indexedDB.open(DBNAME, DBVERSION);
      openreq.onerror = function withStoreOnError() {
        console.error("asyncStorage: can't open database:", openreq.error.name);
      };
      openreq.onupgradeneeded = function withStoreOnUpgradeNeeded() {
        // First time setup: create an empty object store
        openreq.result.createObjectStore(STORENAME);
      };
      openreq.onsuccess = function withStoreOnSuccess() {
        db = openreq.result;
        f(db.transaction(STORENAME, type).objectStore(STORENAME));
      };
    }
  }

  function getItem(key, callback) {
    withStore('readonly', function getItemBody(store) {
      var req = store.get(key);
      req.onsuccess = function getItemOnSuccess() {
        var value = req.result;
        if (value === undefined)
          value = null;
        callback(value);
      };
      req.onerror = function getItemOnError() {
        console.error('Error in asyncStorage.getItem(): ', req.error.name);
      };
    });
  }

  function setItem(key, value, callback) {
    withStore('readwrite', function setItemBody(store) {
      var req = store.put(value, key);
      if (callback) {
        req.onsuccess = function setItemOnSuccess() {
          callback();
        };
      }
      req.onerror = function setItemOnError() {
        console.error('Error in asyncStorage.setItem(): ', req.error.name);
      };
    });
  }

  function removeItem(key, callback) {
    withStore('readwrite', function removeItemBody(store) {
      var req = store.delete(key);
      if (callback) {
        req.onsuccess = function removeItemOnSuccess() {
          callback();
        };
      }
      req.onerror = function removeItemOnError() {
        console.error('Error in asyncStorage.removeItem(): ', req.error.name);
      };
    });
  }

  function clear(callback) {
    withStore('readwrite', function clearBody(store) {
      var req = store.clear();
      if (callback) {
        req.onsuccess = function clearOnSuccess() {
          callback();
        };
      }
      req.onerror = function clearOnError() {
        console.error('Error in asyncStorage.clear(): ', req.error.name);
      };
    });
  }

  function length(callback) {
    withStore('readonly', function lengthBody(store) {
      var req = store.count();
      req.onsuccess = function lengthOnSuccess() {
        callback(req.result);
      };
      req.onerror = function lengthOnError() {
        console.error('Error in asyncStorage.length(): ', req.error.name);
      };
    });
  }

  function key(n, callback) {
    if (n < 0) {
      callback(null);
      return;
    }

    withStore('readonly', function keyBody(store) {
      var advanced = false;
      var req = store.openCursor();
      req.onsuccess = function keyOnSuccess() {
        var cursor = req.result;
        if (!cursor) {
          // this means there weren't enough keys
          callback(null);
          return;
        }
        if (n === 0) {
          // We have the first key, return it if that's what they wanted
          callback(cursor.key);
        } else {
          if (!advanced) {
            // Otherwise, ask the cursor to skip ahead n records
            advanced = true;
            cursor.advance(n);
          } else {
            // When we get here, we've got the nth key.
            callback(cursor.key);
          }
        }
      };
      req.onerror = function keyOnError() {
        console.error('Error in asyncStorage.key(): ', req.error.name);
      };
    });
  }

  return {
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    clear: clear,
    length: length,
    key: key
  };
}());

function $(e) {
  return document.querySelector(e);
}
cv = $("canvas"),
c = cv.getContext('2d'),
ed = $("#editor");
keys = [];

ed.spellCheck = false;

cv.height = h = window.innerHeight;
cv.width  = w = window.innerWidth / 2;

document.addEventListener("keypress", function(e) {
  if (e.ctrlKey && e.keyCode == 13) {
    render();
  }
});

function noise(b) {
  for (var i = 0; i < b.length; i+=4) {
    b[i] = b[i+1] = b[i+2] = Math.random() * 255;
    b[i + 3] = 255;
  }
}

function addSavedEntryToList(versions, key) {
  var opt = document.createElement('option');
  keys.push(key);
  opt.innerHTML = key;
  versions.appendChild(opt);
}

function populate() {
  var versions = document.getElementById("versions");
  versions.disabled = true;
  asyncStorage.length(function(len) {
    if (len == 0) {
      return;
    }

    function addOne(i)  {
      asyncStorage.key(i, function(key) {
        addSavedEntryToList(versions, key);

        if (i++ < len - 1) {
          addOne(i);
        } else {
          versions.disabled = false;
        }
      });
    }
    addOne(0);
  });

  versions.addEventListener("change", function() {
    asyncStorage.getItem(versions.options[versions.selectedIndex].value,
    function(value) {
      ed.innerHTML = value;
    });
  });
}

function render() {
  var err = false,
      id = c.createImageData(w, h),
      b = id.data;

  c.clearRect(0, 0, w, h);


  var datestr = new Date().toUTCString(Date.now());

  asyncStorage.setItem(datestr, ed.innerHTML, function() {
  addSavedEntryToList(versions, datestr);

    try {
      var str = ed.textContent;
      eval(str);
    } catch(e) {
      err = true;
    }
    c.putImageData(id, 0, 0);
    if (err) {
      ed.className = "error";
      setTimeout(function() {
        ed.className = "";
      }, 500);
    } else {
      ed.className = "ok";
      setTimeout(function() {
        ed.className = "";
      }, 500);
    }
  });
}
function clearclear() {
  asyncStorage.clear();
}
populate();
</script>
</body>
</html>
